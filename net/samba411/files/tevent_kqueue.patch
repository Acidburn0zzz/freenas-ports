diff --git a/lib/tevent/echo_server.c b/lib/tevent/echo_server.c
index f93d8bc..099ea04 100644
--- a/lib/tevent/echo_server.c
+++ b/lib/tevent/echo_server.c
@@ -633,7 +633,7 @@ int main(int argc, const char **argv)
 		exit(1);
 	}
 
-	ret = listen(listen_sock, 5);
+	ret = listen(listen_sock, -1);
 	if (ret == -1) {
 		perror("listen() failed");
 		exit(1);
diff --git a/lib/tevent/tevent.c b/lib/tevent/tevent.c
index dbec182..03cc9be 100644
--- a/lib/tevent/tevent.c
+++ b/lib/tevent/tevent.c
@@ -132,6 +132,9 @@ static void tevent_backend_init(void)
 	tevent_epoll_init();
 #elif defined(HAVE_SOLARIS_PORTS)
 	tevent_port_init();
+#elif defined(HAVE_KQUEUE)
+	tevent_kqueue_init();
+	
 #endif
 
 	tevent_standard_init();
diff --git a/lib/tevent/tevent_immediate.c b/lib/tevent/tevent_immediate.c
index d7f8dcc..134c75c 100644
--- a/lib/tevent/tevent_immediate.c
+++ b/lib/tevent/tevent_immediate.c
@@ -139,7 +139,7 @@ int tevent_common_invoke_immediate_handler(struct tevent_immediate *im,
 		*removed = false;
 	}
 
-	tevent_debug(ev, TEVENT_DEBUG_TRACE,
+	tevent_debug(ev, TEVENT_DEBUG_FATAL,
 		     "Run immediate event \"%s\": %p\n",
 		     im->handler_name, im);
 
diff --git a/lib/tevent/tevent_internal.h b/lib/tevent/tevent_internal.h
index 5365fce..91c9495 100644
--- a/lib/tevent/tevent_internal.h
+++ b/lib/tevent/tevent_internal.h
@@ -466,6 +466,12 @@ void tevent_epoll_set_panic_fallback(struct tevent_context *ev,
 bool tevent_port_init(void);
 #endif
 
+#ifdef HAVE_KQUEUE
+bool tevent_kqueue_init(void);
+void tevent_kqueue_set_panic_fallback(struct tevent_context *ev,
+			bool (*panic_fallback)(struct tevent_context *ev,
+					       bool replay));
+#endif
 
 void tevent_trace_point_callback(struct tevent_context *ev,
 				 enum tevent_trace_point);
diff --git a/lib/tevent/tevent_kqueue.c b/lib/tevent/tevent_kqueue.c
new file mode 100644
index 0000000..d5d7712
--- /dev/null
+++ b/lib/tevent/tevent_kqueue.c
@@ -0,0 +1,627 @@
+/* 
+   Unix SMB/CIFS implementation.
+
+   main select loop and event handling - epoll implementation
+
+   Copyright (C) Andrew Tridgell	2003-2005
+   Copyright (C) Stefan Metzmacher	2005-2013
+   Copyright (C) Jeremy Allison		2013
+
+     ** NOTE! The following LGPL license applies to the tevent
+     ** library. This does NOT imply that all of Samba is released
+     ** under the LGPL
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 3 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, see <http://www.gnu.org/licenses/>.
+*/
+#include <sys/cdefs.h>
+#include "replace.h"
+#include <sys/event.h>
+#include "system/filesys.h"
+#include "system/select.h"
+#include "tevent.h"
+#include "tevent_internal.h"
+#include "tevent_util.h"
+
+struct kqueue_event_context {
+	/* a pointer back to the generic event_context */
+	struct tevent_context *ev;
+
+	/* when using kqueue this is kernel event queue */
+	int kqueue_fd;
+
+	pid_t pid;
+
+	bool panic_force_replay;
+	bool *panic_state;
+	bool (*panic_fallback)(struct tevent_context *ev, bool replay);
+};
+
+/*
+  called to set the panic fallback function.
+*/
+_PRIVATE_ void tevent_kqueue_set_panic_fallback(struct tevent_context *ev,
+				bool (*panic_fallback)(struct tevent_context *ev,
+						       bool replay))
+{
+	struct kqueue_event_context *kqueue_ev =
+		talloc_get_type_abort(ev->additional_data,
+		struct kqueue_event_context);
+
+	kqueue_ev->panic_fallback = panic_fallback;
+}
+
+/*
+  called when a kqueue call fails
+*/
+static void kqueue_panic(struct kqueue_event_context *kqueue_ev,
+			 const char *reason, bool replay)
+{
+	struct tevent_context *ev = kqueue_ev->ev;
+	bool (*panic_fallback)(struct tevent_context *ev, bool replay);
+
+	panic_fallback = kqueue_ev->panic_fallback;
+
+	if (kqueue_ev->panic_state != NULL) {
+		*kqueue_ev->panic_state = true;
+	}
+
+	if (kqueue_ev->panic_force_replay) {
+		replay = true;
+	}
+
+	if (panic_fallback == NULL) {
+		tevent_debug(ev, TEVENT_DEBUG_FATAL,
+			"%s (%s) replay[%u] - calling abort()\n",
+			reason, strerror(errno), (unsigned)replay);
+		abort();
+	}
+
+	tevent_debug(ev, TEVENT_DEBUG_ERROR,
+		     "%s (%s) replay[%u] - calling panic_fallback\n",
+		     reason, strerror(errno), (unsigned)replay);
+
+	if (!panic_fallback(ev, replay)) {
+		/* Fallback failed. */
+		tevent_debug(ev, TEVENT_DEBUG_FATAL,
+			"%s (%s) replay[%u] - calling abort()\n",
+			reason, strerror(errno), (unsigned)replay);
+		abort();
+	}
+}
+
+/*
+  map from TEVENT_FD_* to EPOLLIN/EPOLLOUT
+*/
+static short kqueue_map_flags(uint16_t flags)
+{
+	short ret = 0;
+	if (flags & TEVENT_FD_READ) ret |= EVFILT_READ;
+	if (flags & TEVENT_FD_WRITE) ret |= EVFILT_WRITE;
+	return ret;
+}
+
+/*
+ free the kqueue fd
+*/
+static int kqueue_ctx_destructor(struct kqueue_event_context *kqueue_ev)
+{
+	tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_FATAL,
+		"called kqueue_ctx_destructor\n");
+	close(kqueue_ev->kqueue_fd);
+	kqueue_ev->kqueue_fd = -1;
+	return 0;
+}
+
+/*
+ init the kqueue fd
+*/
+static int kqueue_init_ctx(struct kqueue_event_context *kqueue_ev)
+{
+	kqueue_ev->kqueue_fd = kqueue();
+	if (kqueue_ev->kqueue_fd == -1) {
+		tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_FATAL,
+			     "Failed to create kqueue: %s \n", strerror(errno));
+		return -1;
+	}
+
+	if (!ev_set_close_on_exec(kqueue_ev->kqueue_fd)) {
+		tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_WARNING,
+			     "Failed to set close-on-exec, file descriptor may be leaked to children.\n");
+	}
+
+	kqueue_ev->pid = getpid();
+	talloc_set_destructor(kqueue_ev, kqueue_ctx_destructor);
+
+	return 0;
+}
+
+static void kqueue_update_event(struct kqueue_event_context *kqueue_ev, struct tevent_fd *fde);
+
+/*
+  kqueue:
+  The kqueue queue is not inherited by a child created with fork(2).
+ */
+static void kqueue_check_reopen(struct kqueue_event_context *kqueue_ev)
+{
+	struct tevent_fd *fde;
+	bool *caller_panic_state = kqueue_ev->panic_state;
+	bool panic_triggered = false;
+
+	if (kqueue_ev->pid == getpid()) {
+		tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_WARNING,
+			     "stored pid same.\n");
+		return;
+	}
+
+	close(kqueue_ev->kqueue_fd);
+	kqueue_ev->kqueue_fd = kqueue(); 
+	tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_WARNING,
+		     "created new kqueue.\n");
+
+	if (kqueue_ev->kqueue_fd == -1) {
+		tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_WARNING,
+			     "Failed to create new queue.\n");
+		kqueue_panic(kqueue_ev, "kqueue() failed", false);
+		return;
+	}
+
+	if (!ev_set_close_on_exec(kqueue_ev->kqueue_fd)) {
+		tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_WARNING,
+			     "Failed to set close-on-exec, file descriptor may be leaked to children.\n");
+	}
+
+	kqueue_ev->pid = getpid();
+	kqueue_ev->panic_state = &panic_triggered;
+	for (fde=kqueue_ev->ev->fd_events;fde;fde=fde->next) {
+		kqueue_update_event(kqueue_ev, fde);
+
+		if (panic_triggered) {
+			if (caller_panic_state != NULL) {
+				*caller_panic_state = true;
+			}
+			return;
+		}
+	}
+	kqueue_ev->panic_state = NULL;
+	tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_WARNING,
+			     "exiting after changing pid.\n");
+}
+
+/*
+ add the kqueue event to the given fd_event
+*/
+static void kqueue_add_event(struct kqueue_event_context *kqueue_ev, struct tevent_fd *fde)
+{
+	struct kevent k_event;
+	int ret;
+	short filter;	/* filter for a kevent */
+
+	filter = kqueue_map_flags(fde->flags);
+	/* initialize kevent */
+	ZERO_STRUCT(k_event);
+	EV_SET(&k_event, fde->fd, filter, EV_ADD | EV_ENABLE, 0, 0, fde);	
+
+	/*
+	 * Attach event to kqueue. Re-adding an existing event
+	 * will modify the parameters of the original event, and not
+	 * result in a duplicate entry.
+	 */
+	ret = kevent(kqueue_ev->kqueue_fd, &k_event, 1, NULL, 0, NULL); 
+	if (ret != 0 && errno == EBADF) {
+		tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_ERROR,
+			     "KEVENT EBADF for "
+			     "fde[%p] fd[%d] - disabling\n",
+			     fde, fde->fd);
+		DLIST_REMOVE(kqueue_ev->ev->fd_events, fde);
+		fde->wrapper = NULL;
+		fde->event_ctx = NULL;
+		return;
+	} else if (ret != 0) {
+		kqueue_panic(kqueue_ev, "KEVENT add failed", false);
+		return;
+	}
+}
+
+/*
+ delete the kqueue event for given fd_event
+*/
+static void kevent_del_event(struct kqueue_event_context *kqueue_ev, struct tevent_fd *fde)
+{
+	struct kevent event;
+	int ret;
+
+	ZERO_STRUCT(event);
+	EV_SET(&event, fde->fd, 0, EV_DELETE, 0, 0, NULL);
+	ret = kevent(kqueue_ev->kqueue_fd, &event, 1, NULL, 0, NULL);
+	if (ret != 0 && errno == ENOENT) {
+		/*
+		 * This can happen after a epoll_check_reopen
+		 * within epoll_event_fd_destructor.
+		 */
+		tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_TRACE,
+			     "KQUEUE_DEL_EVENT ignoring ENOENT for fd[%d]\n",
+			     fde->fd);
+		return;
+	} else if (ret != 0 && errno == EBADF) {
+		tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_WARNING,
+			     "KQUEUE_DEL_EVENT EBADF for "
+			     "fde[%p] fd[%d] - disabling\n",
+			     fde, fde->fd);
+		DLIST_REMOVE(kqueue_ev->ev->fd_events, fde);
+		fde->wrapper = NULL;
+		fde->event_ctx = NULL;
+		return;
+	} else if (ret != 0) {
+		kqueue_panic(kqueue_ev, "KQUEUE_CTL_DEL failed", false);
+		return;
+	}
+}
+
+/*
+ change the kqueue event to the given fd_event
+*/
+static void kqueue_mod_event(struct kqueue_event_context *kqueue_ev, struct tevent_fd *fde)
+{
+	struct kevent event;
+	int ret;
+	short filter;	/* filter for a kevent */
+
+	filter = kqueue_map_flags(fde->flags);
+
+	ZERO_STRUCT(event);
+	/* initialize kevent */
+	EV_SET(&event,
+		fde->fd,
+		filter,
+		EV_ADD | EV_ENABLE,
+		0,
+		0,
+		fde);
+
+	/*
+	 * Attach event to kqueue. Re-adding an existing event
+	 * will modify the parameters of the original event, and not
+	 * result in a duplicate entry.
+	 */
+	ret = kevent(kqueue_ev->kqueue_fd, &event, 1, NULL, 0, NULL); 
+	if (ret != 0 && errno == EBADF) {
+		tevent_debug(kqueue_ev->ev, TEVENT_DEBUG_ERROR,
+			     "kevent() returned EBADF for "
+			     "fde[%p] fd[%d] - disabling\n",
+			     fde, fde->fd);
+		DLIST_REMOVE(kqueue_ev->ev->fd_events, fde);
+		fde->wrapper = NULL;
+		fde->event_ctx = NULL;
+		return;
+	} else if (ret != 0) {
+		kqueue_panic(kqueue_ev, "kevent() failed", false);
+		return;
+	}
+}
+
+static void kqueue_update_event(struct kqueue_event_context *kqueue_ev, struct tevent_fd *fde)
+{
+	bool want_read = (fde->flags & TEVENT_FD_READ);
+	bool want_write= (fde->flags & TEVENT_FD_WRITE);
+
+	if (want_read || want_write) {
+		kqueue_add_event(kqueue_ev, fde);
+		return;
+	}
+}
+
+static int kqueue_event_fd_destructor(struct tevent_fd *fde)
+{
+	struct tevent_context *ev = fde->event_ctx;
+	struct kqueue_event_context *kqueue_ev = NULL;
+	bool panic_triggered = false;
+	int flags = fde->flags;
+
+	if (ev == NULL) {
+		return tevent_common_fd_destructor(fde);
+        }
+	kqueue_ev = talloc_get_type_abort(ev->additional_data,
+					  struct kqueue_event_context);
+
+	/*
+	 * we must remove the event from the list
+	 * otherwise a panic fallback handler may
+	 * reuse invalid memory
+	 */
+        DLIST_REMOVE(ev->fd_events, fde);
+
+	kqueue_ev->panic_state = &panic_triggered;
+	kqueue_check_reopen(kqueue_ev);
+	if (panic_triggered) {
+		return tevent_common_fd_destructor(fde);
+	}
+
+	fde->flags = 0;
+	kqueue_update_event(kqueue_ev, fde);
+	fde->flags = flags;
+	if (panic_triggered) {
+		return tevent_common_fd_destructor(fde);
+	}
+	kqueue_ev->panic_state = NULL;
+
+	return tevent_common_fd_destructor(fde);
+}
+
+
+/*
+  Cope with epoll returning EPOLLHUP|EPOLLERR on an event.
+  Return true if there's nothing else to do, false if
+  this event needs further handling.
+*/
+static bool kqueue_handle_hup_or_err(struct kqueue_event_context *epoll_ev,
+				struct tevent_fd *fde)
+{
+	if (fde == NULL) {
+		/* Nothing to do if no event. */
+		return true;
+	}
+	return false;
+}
+
+/*
+  event loop handling using kqueue
+*/
+static int kqueue_event_loop(struct kqueue_event_context *kqueue_ev, struct timeval *tvalp)
+{
+	int ret, i;
+
+#define MAXEVENTS 1
+	struct kevent received[MAXEVENTS];
+	struct timespec ts, *ts_p = NULL; 
+	//struct timespec ts = { 0, 0 }; 
+	int wait_errno;
+	uint16_t flags = 0;
+	/*
+	 * If timeout is a non-NULL pointer, it specifies a maximum interval
+	 * to wait for an event. If timeout is a NULL pointer, kevent() waits
+	 * indefinetly. To effect a poll, the timeout argument should be non-NULL,
+	 * pointing to a zero-valued timespec structure.
+	 */
+	if (tvalp != NULL) {
+		tevent_debug(kqueue_ev, TEVENT_DEBUG_FATAL,
+			"setting timeval\n");
+		ts.tv_sec = tvalp->tv_sec;
+		ts.tv_nsec = tvalp->tv_usec * 1000;
+		ts_p = &ts;
+	}
+	if (kqueue_ev->ev->signal_events &&
+	    tevent_common_check_signal(kqueue_ev->ev)) {
+		return 0;
+	}
+
+	tevent_trace_point_callback(kqueue_ev->ev, TEVENT_TRACE_BEFORE_WAIT);
+	ret = kevent(kqueue_ev->kqueue_fd,
+		     NULL,		/* changelist */
+		     0,			/* nchanges */
+		     received,		/* eventlist */
+		     MAXEVENTS,		/* nevents */
+		     ts_p);		/* timeout  - may need NULL*/
+
+	wait_errno = errno;
+	tevent_trace_point_callback(kqueue_ev->ev, TEVENT_TRACE_AFTER_WAIT);
+
+	if (ret == -1 && wait_errno == EINTR && kqueue_ev->ev->signal_events) {
+		if (tevent_common_check_signal(kqueue_ev->ev)) {
+			return 0;
+		}
+	}
+
+	if (ret == -1 && wait_errno != EINTR) {
+		kqueue_panic(kqueue_ev, "kevent() failed", true);
+		return -1;
+	}
+
+	if (ret == 0 && tvalp) {
+		/* we don't care about a possible delay here */
+		tevent_common_loop_timer_delay(kqueue_ev->ev);
+		return 0;
+	}
+
+	for (i=0;i<ret;i++) {
+		//kfdd = received[i].ident;
+		struct tevent_fd *fde = talloc_get_type(received[i].udata,
+							struct tevent_fd);
+		flags = 0;
+		if (fde == NULL) {
+			kqueue_panic(kqueue_ev, "kevent() gave bad data", true);
+			return -1;
+		}
+		if (received[i].filter & EVFILT_READ) flags |= TEVENT_FD_READ;
+		if (received[i].filter & EVFILT_WRITE) flags |= TEVENT_FD_WRITE;
+		/*
+		 * make sure we only pass the flags
+		 * the handler is expecting.
+		 */
+		flags &= fde->flags;
+		if (flags) {
+			return tevent_common_invoke_fd_handler(fde, flags, NULL);
+		}
+	}
+
+	return 0;
+}
+
+/*
+  create a epoll_event_context structure.
+*/
+static int kqueue_event_context_init(struct tevent_context *ev)
+{
+	int ret;
+	struct kqueue_event_context *kqueue_ev;
+
+	/*
+	 * We might be called during tevent_re_initialise()
+	 * which means we need to free our old additional_data.
+	 */
+	TALLOC_FREE(ev->additional_data);
+
+	kqueue_ev = talloc_zero(ev, struct kqueue_event_context);
+	if (!kqueue_ev) return -1;
+	kqueue_ev->ev = ev;
+	kqueue_ev->kqueue_fd = -1;
+
+	ret = kqueue_init_ctx(kqueue_ev);
+	if (ret != 0) {
+		talloc_free(kqueue_ev);
+		return ret;
+	}
+
+	ev->additional_data = kqueue_ev;
+	return 0;
+}
+/*
+  add a fd based event
+  return NULL on failure (memory allocation error)
+*/
+static struct tevent_fd *kqueue_event_add_fd(struct tevent_context *ev, TALLOC_CTX *mem_ctx,
+					     int fd, uint16_t flags,
+					     tevent_fd_handler_t handler,
+					     void *private_data,
+					     const char *handler_name,
+					     const char *location)
+{
+	struct kqueue_event_context *kqueue_ev =
+		talloc_get_type_abort(ev->additional_data,
+		struct kqueue_event_context);
+
+	struct tevent_fd *fde;
+	bool panic_triggered = false;
+
+	fde = tevent_common_add_fd(ev, mem_ctx, fd, flags,
+				   handler, private_data,
+				   handler_name, location);
+	if (!fde) {
+		tevent_debug(ev, TEVENT_DEBUG_FATAL,
+			"tevent_common_add_fd() failed\n");
+		return NULL;
+	}
+
+	talloc_set_destructor(fde, kqueue_event_fd_destructor);
+
+	kqueue_ev->panic_state = &panic_triggered;
+	kqueue_check_reopen(kqueue_ev);
+	if (panic_triggered) {
+		tevent_debug(ev, TEVENT_DEBUG_FATAL,
+			"panic triggered\n");
+		return fde;
+	}
+	kqueue_ev->panic_state = NULL;
+
+	kqueue_update_event(kqueue_ev, fde);
+
+	return fde;
+}
+
+/*
+  set the fd event flags
+*/
+static void kqueue_event_set_fd_flags(struct tevent_fd *fde, uint16_t flags)
+{
+	struct tevent_context *ev;
+	struct kqueue_event_context *kqueue_ev;
+	bool panic_triggered = false;
+
+	if (fde->flags == flags) return;
+
+	ev = fde->event_ctx;
+	kqueue_ev = talloc_get_type_abort(ev->additional_data,
+					  struct kqueue_event_context);
+
+	fde->flags = flags;
+
+	kqueue_ev->panic_state = &panic_triggered;
+	kqueue_check_reopen(kqueue_ev);
+	if (panic_triggered) {
+		return;
+	}
+	kqueue_ev->panic_state = NULL;
+
+	kqueue_update_event(kqueue_ev, fde);
+}
+
+/*
+  do a single event loop using the events defined in ev
+*/
+static int kqueue_event_loop_once(struct tevent_context *ev, const char *location)
+{
+	struct kqueue_event_context *kqueue_ev =
+		talloc_get_type_abort(ev->additional_data,
+		struct kqueue_event_context);
+	struct timeval tval;
+	bool panic_triggered = false;
+
+	if (ev->signal_events &&
+	    tevent_common_check_signal(ev)) {
+		tevent_debug(ev, TEVENT_DEBUG_FATAL,
+			"received signal returning 0\n");
+		return 0;
+	}
+
+	if (ev->threaded_contexts != NULL) {
+		tevent_debug(ev, TEVENT_DEBUG_FATAL,
+			"threaded context\n");
+		tevent_common_threaded_activate_immediate(ev);
+	}
+
+	if (ev->immediate_events &&
+	    tevent_common_loop_immediate(ev)) {
+		tevent_debug(ev, TEVENT_DEBUG_FATAL,
+			"immediate event\n");
+		return 0;
+	}
+
+	tval = tevent_common_loop_timer_delay(ev);
+	if (tevent_timeval_is_zero(&tval)) {
+		tevent_debug(ev, TEVENT_DEBUG_FATAL,
+			"timeval is zero\n");
+		return 0;
+	}
+
+	kqueue_ev->panic_state = &panic_triggered;
+	kqueue_ev->panic_force_replay = true;
+	kqueue_check_reopen(kqueue_ev);
+	if (panic_triggered) {
+		tevent_debug(ev, TEVENT_DEBUG_FATAL,
+			"panic_tiggered in kqueue event loop once\n");
+		errno = EINVAL;
+		return -1;
+	}
+	kqueue_ev->panic_force_replay = false;
+	kqueue_ev->panic_state = NULL;
+
+	return kqueue_event_loop(kqueue_ev, &tval);
+}
+
+static const struct tevent_ops kqueue_event_ops = {
+	.context_init		= kqueue_event_context_init,
+	.add_fd			= kqueue_event_add_fd,
+	.set_fd_close_fn	= tevent_common_fd_set_close_fn,
+	.get_fd_flags		= tevent_common_fd_get_flags,
+	.set_fd_flags		= kqueue_event_set_fd_flags,
+	.add_timer		= tevent_common_add_timer_v2,
+	.schedule_immediate	= tevent_common_schedule_immediate,
+	.add_signal		= tevent_common_add_signal,
+	.loop_once		= kqueue_event_loop_once,
+	.loop_wait		= tevent_common_loop_wait,
+};
+
+_PRIVATE_ bool tevent_kqueue_init(void)
+{
+	return tevent_register_backend("kqueue", &kqueue_event_ops);
+}
diff --git a/lib/tevent/tevent_standard.c b/lib/tevent/tevent_standard.c
index 3872020..3843085 100644
--- a/lib/tevent/tevent_standard.c
+++ b/lib/tevent/tevent_standard.c
@@ -54,7 +54,7 @@ static const struct tevent_ops std_event_ops = {
   Move us to using poll instead. If we return false here,
   caller should abort().
 */
-#ifdef HAVE_EPOLL
+#if defined(HAVE_EPOLL) || defined(HAVE_KQUEUE)
 static bool std_fallback_to_poll(struct tevent_context *ev, bool replay)
 {
 	void *glue_ptr = talloc_parent(ev->ops);
@@ -171,8 +171,11 @@ static int std_event_context_init(struct tevent_context *ev)
 		if (glue == NULL) {
 			return -1;
 		}
-
+#ifdef HAVE_KQUEUE
+		glue->epoll_ops = tevent_find_ops_byname("kqueue");
+#else
 		glue->epoll_ops = tevent_find_ops_byname("epoll");
+#endif
 
 		glue->poll_ops = tevent_find_ops_byname("poll");
 		if (glue->poll_ops == NULL) {
@@ -216,6 +219,9 @@ static int std_event_context_init(struct tevent_context *ev)
 #ifdef HAVE_EPOLL
 		tevent_epoll_set_panic_fallback(ev, std_fallback_to_poll);
 #endif
+#ifdef HAVE_KQUEUE
+		tevent_kqueue_set_panic_fallback(ev, std_fallback_to_poll);
+#endif
 
 		return ret;
 	}
diff --git a/lib/tevent/wscript b/lib/tevent/wscript
index ded182a..0566c6a 100644
--- a/lib/tevent/wscript
+++ b/lib/tevent/wscript
@@ -43,6 +43,9 @@ def configure(conf):
     if conf.CHECK_FUNCS('epoll_create', headers='sys/epoll.h'):
         conf.DEFINE('HAVE_EPOLL', 1)
 
+    if conf.CHECK_FUNCS('kqueue', headers='sys/event.h'):
+        conf.DEFINE('HAVE_KQUEUE', 1)
+
     tevent_num_signals = 64
     v = conf.CHECK_VALUEOF('NSIG', headers='signal.h')
     if v is not None:
@@ -79,6 +82,9 @@ def build(bld):
     if bld.CONFIG_SET('HAVE_EPOLL'):
         SRC += ' tevent_epoll.c'
 
+    if bld.CONFIG_SET('HAVE_KQUEUE'):
+        SRC += ' tevent_kqueue.c'
+
     if bld.CONFIG_SET('HAVE_SOLARIS_PORTS'):
         SRC += ' tevent_port.c'
 
